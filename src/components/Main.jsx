(function () {
	'use strict'

	const { PropTypes } = React
	const { Input, Result, List, Modal } = bf

	const RECORDS_MAX_LENGTH = 3

	const Main = React.createClass({
		displayName: 'Main',

		propTypes: {
			items: PropTypes.array
		},

		getDefaultProps () {
			return {
				items: []
			}
		},

		getInitialState () {
			return {
				source: '',
				items: this.props.items || [],
				records: [],
				value: 0,
				error: null,
				isHelpOpen: false
			}
		},

		_change (source) {
			this.setState({ source })

			try {
				const program = bf.compile(source)
				const { result, error, pointer } = program()

				if (!error) {
					const { items, records } = this.state
					const { length } = source

					// solution array should be immutable
					if (!items[result] || length < items[result].length) {
						items[result] = { result, length, source }

						if (records.length >= RECORDS_MAX_LENGTH) {
							records.shift()
						}
						records.push(result)

						localStorage.setItem('items', JSON.stringify(items))
					}
				}

				this.setState({ result, error, pointer })
			} catch (ex) {
				this.setState({ result: null, error: 'bad program' })
			}
		},

		componentDidMount () {
			this._change('')
		},

		_setSource (index) {
			this._change(this.state.items[index].source)
		},

		_openHelp () {
			this.setState({ isHelpOpen: true })
		},

		_closeHelp () {
			this.setState({ isHelpOpen: false })
		},

		render () {
			const {
				source,
				result,
				error,
				pointer,
				items,
				records,
				isHelpOpen
			} = this.state

			return (
				<div>
					<div className="input-container">
						<span className="description">
							For every number from 0 to 255 find the shortest brainfuck program that generates it.
							The number should be in the cell indicated by the data pointer after the program terminates.
						</span>

						<Input content={source} onChange={this._change} />
						<button onClick={this._openHelp}>?</button>
					</div>

					<Result
						result={result}
						length={source.length}
						error={error}
						pointer={pointer}
					/>

					<List
						items={items}
						records={records}
						onClick={this._setSource}
					/>

					<Modal
						isOpen={isHelpOpen}
						onClose={this._closeHelp}
					>
						<h4>What is brainfuck?</h4>
						<p>
							A very small yet powerful programming language - read more
							on <a href="https://en.wikipedia.org/wiki/Brainfuck" target="_blank">Wikipedia</a>.
							The IO commands (<code>.,</code>) are disabled for this challenge
							as there is no input buffer and the result is the value of the cell
							indicated by the pointer after the program terminates.
						</p>

						<h4>What is brainfuck golf?</h4>
						<p>
							Writing the shortest brainfuck program (in number of characters) that
							achieves a certain task. In our case the task is generating numbers.
							All 256 numbers can be trivially generated by using long strings
							of <code>+</code>. For all but the first few numbers these are not the
							shortest solutions. There is even an
							entire <a href="http://codegolf.stackexchange.com/">stack exchange</a> website
							dedicated to code golfing.
						</p>

						<h4>What is the size of the cells?</h4>
						<p>Cells are 8-bit, unsigned with wraparound.</p>

						<h4>How much memory is there?</h4>
						<p>The memory consists of 256 memory cells. This is more than enough to
							generate all numbers from 0 to 256.
						</p>

						<h4>When does the program time out?</h4>
						<p>
							When the program executes more than 1000 instructions.
							It is impossible to detect if a program will terminate or not so
							this crude method is used instead to terminate potentially runaway programs.
							It should take less than 1000 instructions to generate any number between 0 and 256.
							It is fairly easy to stumble upon non-terminating programs - the shortest one
							is <code>+[]</code>.
						</p>
					</Modal>
				</div>
			)
		}
	})

	window.bf = window.bf || {}
	window.bf.Main = Main
})()